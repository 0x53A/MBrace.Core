namespace MBrace.Runtime

open System
open System.Collections.Concurrent
open System.Runtime.Serialization

open MBrace.Core
open MBrace.Core.Internals

open MBrace.Runtime
open MBrace.Runtime.Utils
open MBrace.Runtime.Utils.PrettyPrinters

/// A Serializable object used to identify a specific worker in a cluster.
/// Can be used to point computations for execution at specific machines.
[<Sealed; DataContract>]
type WorkerRef private (runtime : IRuntimeManager, workerId : IWorkerId) =
    
    [<DataMember(Name = "RuntimeId")>]
    let runtimeId = runtime.Id
    [<DataMember(Name = "WorkerId")>]
    let workerId = workerId

    let initWorkerStateReader () =
        let rm = RuntimeManagerRegistry.Resolve runtimeId
        let getId = async { return! rm.WorkerManager.TryGetWorkerState workerId }
        CacheAtom.Create(getId, intervalMilliseconds = 100, keepLastResultOnError = true)

    let [<IgnoreDataMember>] mutable cvalue = initWorkerStateReader()
    let [<IgnoreDataMember>] mutable logPoller : ILogPoller<SystemLogEntry> option = None
    let [<IgnoreDataMember>] mutable lockObj = new obj()

    let getLogPoller() =
        match logPoller with
        | Some p -> p
        | None ->
            lock lockObj (fun () ->
                match logPoller with
                | None ->
                    let p = runtime.RuntimeSystemLogManager.CreateWorkerLogPoller workerId |> Async.RunSync
                    logPoller <- Some p
                    p
                | Some p -> p)

    let getState () =
        match cvalue.Value with
        | None -> invalidOp <| sprintf "Worker '%s' is no longer part of runtime '%s'." workerId.Id runtimeId.Id
        | Some cv -> cv

    [<OnDeserialized>]
    let _onDeserialized (_ : StreamingContext) =
        lockObj <- new obj()
        cvalue <- initWorkerStateReader()

    /// Runtime identifier
    member __.RuntimeId = runtimeId
    /// Worker identifier
    member __.WorkerId = workerId

    /// Gets the worker hostname
    member __.Hostname = getState().Info.Hostname
    /// Worker identifier
    member __.Id = workerId.Id
    /// Gets the total cpu usage percentage of the worker host
    member __.CpuUsage = getState().PerformanceMetrics.CpuUsage
    /// Gets the total processor count of the worker host
    member __.ProcessorCount = getState().Info.ProcessorCount
    /// Gets the OS identifier of the worker process
    member __.ProcessId = getState().Info.ProcessId
    /// Gets the Max Cpu clock speed in MHz
    member __.MaxCpuClock = getState().PerformanceMetrics.MaxClockSpeed
    /// Gets the total memory usage of the worker host in MB
    member __.MemoryUsage = getState().PerformanceMetrics.MemoryUsage
    /// Gets the total memory capacity of the worker host in MB
    member __.TotalMemory = getState().PerformanceMetrics.TotalMemory
    /// Gets the number of cloud work items that are active in the current worker
    member __.ActiveWorkItems = getState().CurrentWorkItemCount
    /// Gets the maximum work item count permitted as set by worker configuration
    member __.MaxWorkItemCount = getState().Info.MaxWorkItemCount
    /// Gets the network upload usage in KB/s
    member __.NetworkUsageUp = getState().PerformanceMetrics.NetworkUsageUp
    /// Gets the network download usage in KB/s
    member __.NetworkUsageDown = getState().PerformanceMetrics.NetworkUsageDown
    /// Gets the latest time that a worker heartbeat was received
    member __.LastHeartbeat = getState().LastHeartbeat
    /// Gets the initialization/subscription time of the worker process
    member __.InitializationTime = getState().InitializationTime
    /// Gets the worker execution status
    member __.Status = getState().ExecutionStatus
    
    /// <summary>
    ///     Asynchronously fetches all system logs generated by worker instance
    /// </summary>
    /// <param name="logLevel">Maximum log level to display. Defaults to LogLevel.Info.</param>
    /// <param name="filter">User-specified log entry filtering function.</param>
    member __.GetSystemLogsAsync(?logLevel : LogLevel, ?filter : SystemLogEntry -> bool) = async {
        let filter = defaultArg filter (fun _ -> true)
        let logLevel = defaultArg logLevel LogLevel.Info
        let! logs = runtime.RuntimeSystemLogManager.GetWorkerLogs(workerId)
        return logs |> Seq.filter (fun e -> e.LogLevel <= logLevel && filter e) |> Seq.toArray
    }

    /// <summary>
    ///     Fetches all system logs generated by worker instance
    /// </summary>
    /// <param name="logLevel">Maximum log level to display. Defaults to LogLevel.Info.</param>
    /// <param name="filter">User-specified log entry filtering function.</param>
    member __.GetSystemLogs(?logLevel : LogLevel, ?filter : SystemLogEntry -> bool) = 
        __.GetSystemLogsAsync(?logLevel = logLevel, ?filter = filter) |> Async.RunSync

    /// Asynchronously clears system logs for current worker from store.
    member __.ClearSystemLogsAsync() =
        runtime.RuntimeSystemLogManager.ClearLogs(id = workerId)

    /// Clears system logs for current worker from store.
    member __.ClearSystemLogs() =
        __.ClearSystemLogsAsync() |> Async.RunSync

    /// <summary>
    ///     Prints all system logs generated by worker instance to stdout.
    /// </summary>
    /// <param name="logLevel">Maximum log level to display. Defaults to LogLevel.Info.</param>
    /// <param name="filter">User-specified log entry filtering function.</param>
    member __.ShowSystemLogs(?logLevel : LogLevel, ?filter : SystemLogEntry -> bool) = 
        let logLevel = defaultArg logLevel LogLevel.Info
        let filter = defaultArg filter (fun _ -> true)
        runtime.RuntimeSystemLogManager.GetWorkerLogs workerId
        |> Async.RunSync
        |> Seq.filter (fun e -> e.LogLevel <= logLevel && filter e)
        |> Seq.map (fun e -> SystemLogEntry.Format(e, showDate = true, showSourceId = false))
        |> Seq.iter Console.WriteLine

    /// Event for subscribing to worker-specific system logs
    [<CLIEvent>]
    member __.SystemLogs = getLogPoller() :> IEvent<SystemLogEntry>

    override __.Equals(other:obj) =
        match other with
        | :? WorkerRef as w -> areReflectiveEqual runtimeId w.RuntimeId && areReflectiveEqual workerId w.WorkerId
        | _ -> false

    override __.GetHashCode() = hash2 runtimeId workerId

    override __.ToString() = workerId.ToString()

    interface IWorkerRef with
        member x.CompareTo(obj: obj): int = 
            match obj with
            | :? WorkerRef as w -> compare2 runtimeId workerId w.RuntimeId w.WorkerId
            | _ -> invalidArg "obj" "invalid comparand."
        
        member x.Hostname: string = 
            getState().Info.Hostname
        
        member x.Id: string = 
            workerId.Id
        
        member x.ProcessId: int = 
            getState().Info.ProcessId
        
        member x.ProcessorCount: int = 
            getState().Info.ProcessorCount

        member x.MaxCpuClock = 
            match x.MaxCpuClock with
            | c when c.HasValue -> c.Value
            | _ -> invalidOp "Could not get CPU clock speed for worker."
        
        member x.Type: string = 
           runtimeId.Id

    /// Gets a printed report on worker status
    member w.GetInfo() : string = WorkerReporter.Report([|w|], "Worker", borders = false)
    /// Prints a report on worker to stdout
    member w.ShowInfo () : unit = Console.WriteLine(w.GetInfo())

    /// <summary>
    ///     Creates a new WorkerRef instance for given runtime and worker id.
    /// </summary>
    /// <param name="runtime">Runtime management object.</param>
    /// <param name="workerId">Worker identifier.</param>
    static member Create(runtime : IRuntimeManager, workerId : IWorkerId) =
        new WorkerRef(runtime, workerId)

    /// Gets the hostname of the current process
    static member CurrentHostname = System.Net.Dns.GetHostName()


/// WorkerRef information reporting
and internal WorkerReporter private () =
    
    static let template : Field<WorkerRef> list = 
        let inline ( *?) x (y : Nullable<_>) =
            if y.HasValue then new Nullable<_>(x * y.Value)
            else new Nullable<_>()

        let inline (?/?) (x : Nullable<_>) (y : Nullable<_>) =
            if x.HasValue && y.HasValue then new Nullable<_>(x.Value / y.Value)
            else new Nullable<_>()

        let double_printer (value : Nullable<double>) = 
            if value.HasValue then sprintf "%.1f" value.Value
            else "N/A"

        [ Field.create "Id" Left (fun w -> w.Id)
          Field.create "Status" Left (fun p -> string p.Status)
          Field.create "% CPU / Cores" Right (fun p -> sprintf "%s / %d" (double_printer p.CpuUsage) p.ProcessorCount)
          Field.create "CPU Clock" Left (fun p -> sprintf "%s MHz" (double_printer p.MaxCpuClock))
          Field.create "% Memory / Total(MB)" Right (fun p ->
                let memPerc = 100. *? p.MemoryUsage ?/? p.TotalMemory |> double_printer
                sprintf "%s / %s" memPerc <| double_printer p.TotalMemory
            )
          Field.create "Network(ul/dl : KB/s)" Right (fun n -> sprintf "%s / %s" <| double_printer n.NetworkUsageUp <| double_printer n.NetworkUsageDown)
          Field.create "Work items" Right (fun p -> sprintf "%d / %d" p.ActiveWorkItems p.MaxWorkItemCount)
          Field.create "Hostname" Left (fun p -> sprintf "%s" p.Hostname)
          Field.create "PID" Right (fun p -> p.ProcessId)
          Field.create "Initialization Time" Left (fun p -> let d = p.InitializationTime in d.LocalDateTime) 
          Field.create "Latest Heartbeat" Left (fun p -> let d = p.LastHeartbeat in d.LocalDateTime)
        ]
    
    /// <summary>
    ///     Generates a string displaying information on provided workers.
    /// </summary>
    /// <param name="workers">Workers to be displayed.</param>
    /// <param name="title">Title for display.</param>
    /// <param name="borders">Use borders for displayed information.</param>
    static member Report(workers : seq<WorkerRef>, title : string, borders : bool) : string = 
        let ws = workers
                 |> Seq.sortBy (fun w -> w.InitializationTime)
                 |> Seq.toList

        Record.PrettyPrint(template, ws, title, borders)